/*
Copyright IBM Corp. 2016 All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

		 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tcert

import (
	"crypto"
	"crypto/sha256"
	"crypto/x509"
	"errors"
	"fmt"
	"time"

	"github.com/cloudflare/cfssl/log"
	"github.com/hyperledger/fabric-ca/lib/csputil"
	"github.com/hyperledger/fabric/bccsp"

	"hash"
	"math/big"
)

// LoadMgr creates and initializes the manager for a CA
// @parameter caKeyFile is the file name for the CA's key
// @parameter caCertFile is the file name for the CA's cert
func LoadMgr(caKeyFile, caCertFile string, csp bccsp.BCCSP) (*Mgr, error) {
	caKey, caSigner, caCert, err := csputil.LoadKeyAndCert(caKeyFile, caCertFile, csp)
	if err != nil {
		return nil, err
	}
	mgr, err := NewMgr(csp)
	if err != nil {
		return nil, err
	}
	mgr.InitCA(caKey, caSigner, caCert)
	return mgr, nil
}

// NewMgr is the constructor for a TCert manager
func NewMgr(csp bccsp.BCCSP) (*Mgr, error) {
	mgr := new(Mgr)
	if csp == nil {
		return nil, errors.New("No CSP was provided to the TCert Manager")
	}
	mgr.csp = csp
	mgr.validityPeriod = time.Hour * 24 * 365 // default to 1 year
	mgr.maxAllowedBatchSize = 1000
	mgr.hashFunction = sha256.New
	return mgr, nil
}

// Mgr is the top-level object for the TCert library
type Mgr struct {
	// The crypto service provider abstraction
	csp bccsp.BCCSP
	// caKey is the private key of the CA
	caKey bccsp.Key
	// caSigner is used for signing a certificate request
	caSigner crypto.Signer
	// caCert is used for extracting CA data to associate with issued certificates
	caCert *x509.Certificate
	// validityPeriod is both the max and the default validity period for TCert factories.
	// The default value is 1 year.
	validityPeriod time.Duration
	// MaxAllowedBatchSize is the maximum number of TCerts which can be requested at a time.
	// The default value is 1000.
	maxAllowedBatchSize int
	// The hash function for this manager
	hashFunction func() hash.Hash
}

// InitCA sets CA's key and certificate
func (mgr *Mgr) InitCA(caKey bccsp.Key, caSigner crypto.Signer, caCert *x509.Certificate) {
	mgr.caKey = caKey
	mgr.caSigner = caSigner
	mgr.caCert = caCert
}

// SetValidityPeriod sets the validity period for the manager
// This is both the max and the default validity period for TCert factories.
func (mgr *Mgr) SetValidityPeriod(vp time.Duration) {
	mgr.validityPeriod = vp
}

// SetHashFunction sets the hash function
func (mgr *Mgr) SetHashFunction(hashFunction func() hash.Hash) {
	mgr.hashFunction = hashFunction
}

// GetBatch gets a batch of TCerts from the server to return to a client
// @parameter req Is the TCert batch request
// @parameter ecert Is the enrollment certificate of the caller
func (mgr *Mgr) GetBatch(req *GetBatchRequest, ecert *x509.Certificate) (*GetBatchResponse, error) {

	log.Debugf("GetBatch req=%+v", req)

	// Create a factory from which to create tcerts for this batch
	fact, err := mgr.NewFactory(ecert, nil)
	if err != nil {
		return nil, fmt.Errorf("Failed to create TCert factory: %s", err)
	}

	fact.SetPreKey(req.PreKey)
	fact.SetAttributes(req.Attrs, req.EncryptAttrs)

	// Decrease the validity period on tcerts generated by this factory
	// if the requester wants a shorter validity period
	if req.ValidityPeriod > 0 && req.ValidityPeriod < mgr.validityPeriod {
		fact.SetValidityPeriod(req.ValidityPeriod)
	}

	// Set numTCertsInBatch to the number of TCerts to get.
	// If 0 are requested, retrieve the maximum allowable;
	// otherwise, retrieve the number requested it not too many.
	var numTCertsInBatch int
	if req.Count == 0 {
		numTCertsInBatch = int(mgr.maxAllowedBatchSize)
	} else if req.Count <= mgr.maxAllowedBatchSize {
		numTCertsInBatch = int(req.Count)
	} else {
		return nil, fmt.Errorf("You may not request %d TCerts; the maximum is %d",
			req.Count, mgr.maxAllowedBatchSize)
	}

	// Generate as many tcerts as were requested
	var tcerts []TCert
	for i := 0; i < numTCertsInBatch; i++ {
		tcert, err := fact.GenTCert()
		if err != nil {
			return nil, err
		}
		tcerts = append(tcerts, *tcert)
	}

	tcertResponse := &GetBatchResponse{
		ID:     GenNumber(big.NewInt(20)),
		TS:     time.Now(),
		Key:    fact.KDFKey(),
		TCerts: tcerts,
	}

	return tcertResponse, nil
}
