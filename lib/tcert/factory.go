/*
Copyright IBM Corp. 2016 All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

		 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tcert

import (
	"crypto"
	"crypto/hmac"
	"crypto/rand"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/binary"
	"errors"
	"fmt"
	"time"

	"github.com/hyperledger/fabric-ca/lib/csputil"
	"github.com/hyperledger/fabric/bccsp"

	"hash"
	"math/big"
	"strconv"
)

const (
	oidBase     = 7
	oidAttrBase = 9
)

var (
	// tcertIndexOID is the ASN1 object identifier of the TCert index.
	tcertIndexOID = newOID(oidBase)

	// tcertEnrollmentIDOID is the ASN1 object identifier of the enrollment id.
	tcertEnrollmentIDOID = newOID(oidBase + 1)

	// padding for encryption.
	padding = []byte{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}

	// tcertSubject is the subject name placed in all generated TCerts
	tcertSubject = pkix.Name{CommonName: "Fabric Transaction Certificate"}

	byte1 = []byte{1}

	byte2 = []byte{2}

	one = new(big.Int).SetInt64(1)
)

// NewFactory creates a transaction certificate (TCert) factory from which
// TCerts are generated.
// @parameter ecert Is the enrollment certificate from which to generate tcerts
// @parameter kdfKey Is the optional Key Derivation Function key.
// If nil as for a server-side factory,
func (mgr *Mgr) NewFactory(ecert *x509.Certificate, kdfKey []byte) (*Factory, error) {

	// Create a TCert factory
	fact := new(Factory)
	fact.mgr = mgr
	fact.ecert = ecert
	fact.csp = mgr.csp
	fact.enrollmentID = append([]byte(GetEnrollmentIDFromCert(ecert)), padding...)
	fact.hashFunction = mgr.hashFunction
	fact.validityPeriod = mgr.validityPeriod

	// Create a template from which to create all other TCerts.
	fact.template = &x509.Certificate{Subject: tcertSubject}
	fact.template.IsCA = false
	fact.template.KeyUsage = x509.KeyUsageDigitalSignature
	fact.template.SubjectKeyId = []byte{1, 2, 3, 4}

	// Generate nonce for the tcert index
	fact.nonce = make([]byte, 16) // 8 bytes rand, 8 bytes timestamp
	rand.Reader.Read(fact.nonce[:8])
	binary.LittleEndian.PutUint64(fact.nonce[8:], uint64(time.Now().Unix()))

	pk, err := mgr.csp.KeyImport(ecert, &bccsp.X509PublicKeyImportOpts{Temporary: true})
	if err != nil {
		return nil, fmt.Errorf("Failed to get signer for ECert: %s", err)
	}
	fact.ecertPublicKey = pk

	if kdfKey == nil {
		// Generate the KDF key.
		raw, _ := x509.MarshalPKIXPublicKey(ecert.PublicKey)
		kdfKey = fact.hmac(createHMACKey(), raw)
	}

	fact.keys = newKeys(kdfKey, fact.hashFunction)

	return fact, nil
}

// Factory is factory for generating transaction certificates
type Factory struct {
	mgr             *Mgr
	ecert           *x509.Certificate
	csp             bccsp.BCCSP
	ecertPublicKey  bccsp.Key
	ecertPrivateKey bccsp.Key
	template        *x509.Certificate
	enrollmentID    []byte
	attrs           []Attribute
	encryptAttrs    bool
	hashFunction    func() hash.Hash
	validityPeriod  time.Duration
	idx             int
	nonce           []byte
	keys            *keys
	preKey          string
	N               *big.Int
}

// KDFKey returns the Key Derivation Function key which is used to generate tcerts
func (fact *Factory) KDFKey() []byte {
	return fact.keys.kdf
}

// SetAttributes sets the attribute names and values which are added to the
// extensions section of generated TCerts.
func (fact *Factory) SetAttributes(attrs []Attribute, encrypt bool) {
	fact.attrs = attrs
	fact.encryptAttrs = encrypt
}

// SetECertPrivateKey sets the enrollment certificate's private key
func (fact *Factory) SetECertPrivateKey(key bccsp.Key) {
	fact.ecertPrivateKey = key
}

// SetValidityPeriod sets the validity period for tcerts generated by this factory
func (fact *Factory) SetValidityPeriod(vp time.Duration) {
	fact.validityPeriod = vp
}

// SetPreKey sets the preKey to use in generating tcerts
func (fact *Factory) SetPreKey(preKey string) {
	fact.preKey = preKey
}

// GenTCert generates a single TCert
func (fact *Factory) GenTCert() (*TCert, error) {

	if fact.preKey == "" {
		return nil, errors.New("The preKey is not set")
	}

	tcertid, err := GenerateIntUUID()
	if err != nil {
		return nil, fmt.Errorf("Failure generating UUID: %s", err)
	}

	// Compute TCertIndex
	tidx := []byte(strconv.Itoa(2*fact.idx + 1))
	tidx = append(tidx, fact.nonce...)
	tidx = append(tidx, padding...)
	fact.idx++

	tidxKey := fact.hmac(fact.keys.expansion, tidx)

	// Derive the public key
	csp := fact.mgr.csp
	opts := &bccsp.ECDSAReRandKeyOpts{
		Temporary: true,
		Expansion: tidxKey,
	}
	derivedPubKey, err := csp.KeyDeriv(fact.ecertPublicKey, opts)
	if err != nil {
		return nil, fmt.Errorf("Failed deriving public key: %s", err)
	}
	pubSigner, err := csputil.Key2Signer(derivedPubKey, csp)
	if err != nil {
		return nil, err
	}
	pubKey := pubSigner.Public()

	// Compute the encrypted TCertIndex
	encryptedTidx, err := CBCPKCS7Encrypt(fact.keys.extension, tidx)
	if err != nil {
		return nil, fmt.Errorf("Failed to encrypt tcert index: %s", err)
	}

	extensions, certKeys, err := fact.getExtensions(tcertid, encryptedTidx)
	if err != nil {
		return nil, fmt.Errorf("Failed to create extensions: %s", err)
	}

	// Fill in the tcert-specific portions of the certificate template
	template := fact.template
	template.NotBefore = time.Now()
	template.NotAfter = template.NotBefore.Add(fact.validityPeriod)
	template.PublicKey = pubKey
	template.Extensions = extensions
	template.ExtraExtensions = extensions
	template.SerialNumber = tcertid

	var cert []byte
	var signer crypto.Signer

	// If private key is set, we generate a self-signed tcert
	if fact.ecertPrivateKey != nil {
		signer, err = fact.derivePrivateSigner(tidx)
		if err != nil {
			return nil, err
		}
		cert, err = x509.CreateCertificate(rand.Reader, template, template, pubKey, signer)
		if err != nil {
			return nil, fmt.Errorf("Failed to create self-signed x509 certificate: %s", err)
		}
	} else {
		caSigner := fact.mgr.caSigner
		caCert := fact.mgr.caCert
		if caSigner == nil {
			return nil, errors.New("No CA signer; call InitCA")
		}
		if caCert == nil {
			return nil, errors.New("No CA certificate; call InitCf")
		}
		cert, err = x509.CreateCertificate(rand.Reader, template, caCert, pubKey, caSigner)
		if err != nil {
			return nil, fmt.Errorf("Failed to create x509 certificate: %s", err)
		}
	}
	return &TCert{Cert: cert, Keys: certKeys, signer: signer}, nil
}

// SetTCertPrivateSigner sets the private signer of a tcert.
// This is done on the client-side after receiving a TCert from the server.
func (fact *Factory) SetTCertPrivateSigner(tcert *TCert) error {
	keys := fact.keys
	tidx, err := tcert.GetExtensionValue("hf.tcertIdx", tcertIndexOID, keys.extension)
	if err != nil {
		return err
	}
	signer, err := fact.derivePrivateSigner(tidx)
	if err != nil {
		return err
	}
	tcert.signer = signer
	return nil
}

// Get encrypted extensions to be included into the TCert (TCertIndex, EnrollmentID and attributes).
func (fact *Factory) getExtensions(tcertid *big.Int, tidx []byte) ([]pkix.Extension, *CertKeys, error) {

	attrs := fact.attrs

	// Compute encrypted EnrollmentID
	preK0 := fact.hmac([]byte(fact.preKey), tcertid.Bytes())
	enrollmentIDKey := fact.hmac(preK0, []byte("enrollmentID"))[:32]
	encEnrollmentID, err := CBCPKCS7Encrypt(enrollmentIDKey, fact.enrollmentID)
	if err != nil {
		return nil, nil, fmt.Errorf("Failed to encrypt enrollment ID: %s", err)
	}

	// 'extensions' contains an entry for each attribute, plus entries for
	// the encrypted tcert index and enrollment ID
	numAttrs := len(attrs)
	extensions := make([]pkix.Extension, numAttrs+2)

	// For each attribute, add to extensions and attrKeyMap.
	// Optionally encrypt attribute values.
	attrKeyMap := make(map[string]AttributeKey)
	for i := 0; i < numAttrs; i++ {
		name := attrs[i].Name
		value := []byte(attrs[i].Value)
		// Encrypt attribute if enabled
		var key []byte
		if fact.encryptAttrs {
			key = fact.hmac(preK0, []byte(name))[:32]
			value, err = CBCPKCS7Encrypt(key, value)
			if err != nil {
				return nil, nil, err
			}
		}
		extensions[i] = pkix.Extension{Id: attrIndexToOID(i), Critical: false, Value: value}
		attrKeyMap[name] = AttributeKey{Index: i, Key: key}
	}

	extensions[numAttrs] = pkix.Extension{Id: tcertIndexOID, Critical: true, Value: tidx}
	extensions[numAttrs+1] = pkix.Extension{Id: tcertEnrollmentIDOID, Critical: false, Value: encEnrollmentID}

	certKeys := &CertKeys{
		EnrollmentID: enrollmentIDKey,
		Attributes:   attrKeyMap,
	}

	return extensions, certKeys, nil
}

// Given the tcert index, return the corresponding tcert private signer
func (fact *Factory) derivePrivateSigner(tcertIdx []byte) (crypto.Signer, error) {
	expansionValue := fact.hmac(fact.keys.expansion, tcertIdx)
	opts := &bccsp.ECDSAReRandKeyOpts{
		Temporary: true,
		Expansion: expansionValue,
	}
	csp := fact.mgr.csp
	key, err := csp.KeyDeriv(fact.ecertPrivateKey, opts)
	if err != nil {
		return nil, fmt.Errorf("Failed to derive private key: %s", err)
	}
	return csputil.Key2Signer(key, csp)
}

// Generate an HMAC over 'buf' using the KDF key
func (fact *Factory) hmacKDF(buf []byte) []byte {
	return fact.hmac(fact.keys.kdf, buf)
}

// Generate an HMAC using the factory's hash function
func (fact *Factory) hmac(key, buf []byte) []byte {
	mac := hmac.New(fact.hashFunction, key)
	mac.Write(buf)
	return mac.Sum(nil)
}

// newKeys creates a structure to hold the KDF-related keys
func newKeys(kdf []byte, hf func() hash.Hash) *keys {
	return &keys{
		kdf:       kdf,
		extension: myhmac(kdf, byte1, hf)[:32],
		expansion: myhmac(kdf, byte2, hf),
	}
}

// keys contains the KDF (Key Derivation Function) key and
// also any keys derived from the KDF key
type keys struct {
	kdf, extension, expansion []byte
}
